package org.evosuite.testcase;

import java.io.Serializable;
import java.lang.reflect.Type;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Stack;


import org.evosuite.utils.GenericClass;
import org.junit.Assert;
import org.junit.Test;

import com.googlecode.gentyref.TypeToken;

public class GenericClassTest {

	private static class A{}
	
	@SuppressWarnings({ "rawtypes", "unused", "unchecked" })
	@Test
	public void test01() throws Throwable{

		/*
		 * This test case come from compilation issue found during SBST'13 competition:
		 * 
		 * String string0 = vM0.run(vM0.stack);
		 * 
		 * SUT at:  http://www.massapi.com/source/jabref-2.6/src/java/net/sf/jabref/bst/VM.java.html
		 * 
		 * Snippet of interest:
		 * 
		 * 1) Stack<Object> stack = new Stack<Object>();
		 * 2)  public String run(Collection<BibtexEntry> bibtex) {
		 */
		
		Collection<?> col0 = new Stack<Object>();
		Collection<A> col1 = new Stack();
		Collection col2 = new Stack();
		Collection col3 = new Stack<Object>();
		
		/*
		 *  following does not compile
		 *  
		 *  Collection<A> col = new Stack<Object>();
		 *  
		 *  but it can be generated by EvoSuite
		 */
		
		GenericClass stack = new GenericClass(Stack.class).getWithWildcardTypes();
		GenericClass collection = new GenericClass(Collection.class).getWithWildcardTypes();
		Assert.assertTrue(stack.isAssignableTo(collection));
		
		GenericClass objectStack = new GenericClass(col0.getClass());
		Assert.assertTrue(objectStack.isAssignableTo(collection));
		
	
		Type typeColA = new TypeToken<Collection<A>>(){}.getType();
		Type typeStack = new TypeToken<Stack>(){}.getType();
		Type typeObjectStack = new TypeToken<Stack<Object>>(){}.getType();
		
		GenericClass classColA = new GenericClass(typeColA);
		GenericClass classStack = new GenericClass(typeStack).getWithWildcardTypes();
		GenericClass classObjectStack = new GenericClass(typeObjectStack);
		
		Assert.assertFalse(classStack.isAssignableTo(classColA));
		Assert.assertFalse(classObjectStack.isAssignableTo(classColA));
		Assert.assertFalse(classColA.isAssignableFrom(classObjectStack));
	}
	
	@Test
	public void test1() {
		Type listOfString = new TypeToken<List<String>>(){}.getType();
		Type listOfInteger = new TypeToken<List<Integer>>(){}.getType();
		
		GenericClass listOfStringClass = new GenericClass(listOfString);
		GenericClass listOfIntegerClass = new GenericClass(listOfInteger);
		
		Assert.assertFalse(listOfStringClass.isAssignableFrom(listOfIntegerClass));
		Assert.assertFalse(listOfStringClass.isAssignableTo(listOfIntegerClass));
	}
	
	@SuppressWarnings("rawtypes")
	@Test
	public void test2() {
		Type listOfString = new TypeToken<List<String>>(){}.getType();
		Type plainList = new TypeToken<List>(){}.getType();
		Type objectList = new TypeToken<List<Object>>(){}.getType();
		
		GenericClass listOfStringClass = new GenericClass(listOfString);
		GenericClass plainListClass = new GenericClass(plainList).getWithWildcardTypes();
		GenericClass	 objectListClass = new GenericClass(objectList);

		/*
		 * Note:
		 * 
		 * 		List<String> l = new LinkedList<Object>();
		 * 
		 *  does not compile
		 */
		
		Assert.assertFalse(listOfStringClass.isAssignableTo(objectListClass));

		Assert.assertFalse(listOfStringClass.isAssignableFrom(plainListClass));
		Assert.assertTrue(listOfStringClass.isAssignableTo(plainListClass));		
	}
	
	

	@Test
	public void test3() {
		Type listOfInteger = new TypeToken<List<Integer>>(){}.getType();
		Type listOfSerializable = new TypeToken<List<Serializable>>(){}.getType();
		
		GenericClass listOfIntegerClass = new GenericClass(listOfInteger);
		GenericClass listOfSerializableClass = new GenericClass(listOfSerializable);
		
		Assert.assertFalse(listOfIntegerClass.isAssignableFrom(listOfSerializableClass));
		Assert.assertFalse(listOfSerializableClass.isAssignableFrom(listOfIntegerClass));

		Assert.assertTrue(listOfIntegerClass.isAssignableFrom(listOfIntegerClass));
		Assert.assertTrue(listOfSerializableClass.isAssignableFrom(listOfSerializableClass));

	}
}
