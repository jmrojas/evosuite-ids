/** * Copyright (C) 2013 José Campos and EvoSuite * contributors *  * This file is part of EvoSuite. *  * EvoSuite is free software: you can redistribute it and/or modify it under the * terms of the GNU Public License as published by the Free Software Foundation, * either version 3 of the License, or (at your option) any later version. *  * EvoSuite is distributed in the hope that it will be useful, but WITHOUT ANY * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR * A PARTICULAR PURPOSE. See the GNU Public License for more details. *  * You should have received a copy of the GNU Public License along with * EvoSuite. If not, see <http://www.gnu.org/licenses/>. */package org.evosuite.coverage.diversity;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Set;import org.evosuite.Properties;import org.evosuite.TestGenerationContext;import org.evosuite.graphs.cfg.BytecodeInstruction;import org.evosuite.graphs.cfg.BytecodeInstructionPool;import org.evosuite.testsuite.AbstractFitnessFactory;import org.evosuite.utils.LoggingUtils;/** * <p> * DiversityCoverageFactory class. * </p> *  * @author José Campos */public class DiversityCoverageFactory extends		AbstractFitnessFactory<DiversityCoverageTestFitness>{	private static boolean			called = false;	private static boolean			debug = false;	private static HashMap<String, Double> categories = new HashMap<String, Double>();	private static List<DiversityCoverageTestFitness> goals = new ArrayList<DiversityCoverageTestFitness>();	private static Set<Integer> lineNumbers = new HashSet<Integer>();	private static void computeGoals()	{		if (called)			return ;		Properties.MINIMIZE = false; // FIXME put this somewhere else		long start = System.currentTimeMillis();		String targetMethod = Properties.TARGET_METHOD;		String targetClass = Properties.TARGET_CLASS;		for (String className : BytecodeInstructionPool.getInstance(TestGenerationContext.getClassLoader()).knownClasses())		{			if (!(targetClass.equals("") || className.endsWith(targetClass)))				continue;			for (String methodName : BytecodeInstructionPool.getInstance(TestGenerationContext.getClassLoader()).knownMethods(className))			{				if (!targetMethod.equals("") && !methodName.equals(targetMethod))					continue;				for (BytecodeInstruction ins : BytecodeInstructionPool.getInstance(TestGenerationContext.getClassLoader()).getInstructionsIn(className, methodName)) {					if (isUsable(ins))						goals.add(new DiversityCoverageTestFitness(ins));				}			}		}		long end = System.currentTimeMillis();		LoggingUtils.getEvoLogger().info("* Total number of coverage goals: "		                                         + goals.size() + " took "		                                         + (end - start) + "ms");		called = true;		if (debug) {			for (DiversityCoverageTestFitness e : goals)				LoggingUtils.getEvoLogger().info(e.toString());		}		loadOriginalMatrix();	}	private static boolean isUsable(BytecodeInstruction ins) {		if (lineNumbers.add(ins.getLineNumber()) == false) // the line number already exists, and cannot be added			return false;		return ins.isLineNumber();	}	private static void loadOriginalMatrix()	{		/*		 * Read the original matrix if the Coverage File exists		 */		BufferedReader br = null;		try		{			String sCurrentLine;			br = new BufferedReader(new FileReader("evosuite-report" + File.separator + "data" + File.separator + Properties.TARGET_CLASS + ".matrix"));			String[] split;			while ((sCurrentLine = br.readLine()) != null)			{				split = sCurrentLine.split(" ");				StringBuilder test_coverage = new StringBuilder("");				for (int i = 0; i < split.length - 1; i++) // - 1, because we don't want the test results				{					if (split[i].compareTo("1") == 0)						test_coverage.append("1");					else						test_coverage.append("0");				}				String hash = MD5.hash(test_coverage.toString());				if (categories.get(hash) == null)					categories.put(hash, 1.0);				else					categories.put(hash, categories.get(hash) + 1.0);			}			double N = 0.0;			double sum_ni = 0.0;			for (Double number_of_individual_in_a_category : categories.values()) {				N += number_of_individual_in_a_category;				double ni = number_of_individual_in_a_category * (number_of_individual_in_a_category - 1.0);				sum_ni += ni;			}			N = N * (N - 1.0);			double fitness = sum_ni / N;			LoggingUtils.getEvoLogger().info("* Original fitness: " + fitness);		}		catch (IOException e) {			// the coverage matrix file does not exist, ok no problem... we will generate new test cases from scratch		}		finally {			try {				if (br != null)					br.close();			}			catch (IOException ex) {				ex.printStackTrace();			}		}	}	public static HashMap<String, Double> getCategories() {		return categories;	}	@Override	public List<DiversityCoverageTestFitness> getCoverageGoals() {		if (!called)			computeGoals();		return goals;	}	public static List<DiversityCoverageTestFitness> retrieveCoverageGoals() {		if (!called)			computeGoals();		return goals;	}}