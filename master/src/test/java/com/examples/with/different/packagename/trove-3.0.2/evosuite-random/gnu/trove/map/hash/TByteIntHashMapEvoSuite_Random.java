/*
 * This file was automatically generated by EvoSuite
 */

package gnu.trove.map.hash;

import org.junit.Test;
import static org.junit.Assert.*;
import gnu.trove.map.TByteIntMap;
import gnu.trove.map.hash.TByteIntHashMap;
import gnu.trove.procedure.TByteProcedure;
import gnu.trove.procedure.TIntProcedure;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.StreamCorruptedException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.AbstractMap;
import java.util.Locale;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;

public class TByteIntHashMapEvoSuite_Random {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.utils.LoggingUtils.setLoggingForJUnit(); 
    org.evosuite.Properties.REPLACE_CALLS = true; 
    org.evosuite.agent.InstrumentingAgent.initialize(); 
  } 

  @Before 
  public void initTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.activate(); 
  } 

  @After 
  public void doneWithTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.deactivate(); 
  } 


  @Test
  public void test0()  throws Throwable  {
      byte[] byteArray0 = new byte[6];
      byte byte0 = (byte) (-31);
      byteArray0[0] = byte0;
      byte byte1 = (byte)48;
      byteArray0[1] = byte1;
      String string0 = "";
      String string1 = ". This can manifest itself as an apparent duplicate key.";
      URI uRI0 = null;
      try {
        uRI0 = new URI(string0, string0, string0, string0, string1);
        fail("Expecting exception: URISyntaxException");
      
      } catch(URISyntaxException e) {
         //
         // Expected scheme name at index 0: ://?#.%20This%20can%20manifest%20itself%20as%20an%20apparent%20duplicate%20key.
         //
      }
  }

  @Test
  public void test1()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byte byte0 = (byte) (-1);
      byteArray0[0] = byte0;
      byte byte1 = (byte)93;
      byteArray0[1] = byte1;
      int int0 = 1197;
      float float0 = 0.0F;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap((int) byteArray0[1]);
      tByteIntHashMap0.put(byteArray0[1], byte1);
      byte byte2 = (byte)91;
      byte byte3 = (byte) (-33);
      int int1 = (-1459);
      tByteIntHashMap0.putIfAbsent(byte3, int1);
      assertEquals(2, tByteIntHashMap0.size());
      
      TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap(int0, float0, byte2, (int) byte1);
      byte byte4 = (byte) (-55);
      byteArray0[2] = byte4;
      byte byte5 = (byte)89;
      byteArray0[3] = byte5;
      int[] intArray0 = new int[1];
      intArray0[0] = (int) byteArray0[1];
      TByteIntHashMap tByteIntHashMap2 = new TByteIntHashMap(byteArray0, intArray0);
      int int2 = 1126;
      boolean boolean0 = tByteIntHashMap2.adjustValue(byteArray0[2], int2);
      assertEquals(false, boolean0);
  }

  @Test
  public void test2()  throws Throwable  {
      int int0 = (-244);
      float float0 = 1209.3682F;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(int0, float0);
      Locale locale0 = Locale.JAPAN;
      String string0 = ";r6a@WE`n4hcr}Z";
      // Undeclared exception!
      try {
        locale0.getUnicodeLocaleType(string0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Ill-formed Unicode locale key: ;r6a@WE`n4hcr}Z
         //
      }
  }

  @Test
  public void test3()  throws Throwable  {
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap();
      TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap((TByteIntMap) tByteIntHashMap0);
      byte[] byteArray0 = new byte[7];
      byte byte0 = (byte) (-120);
      byteArray0[0] = byte0;
      byte byte1 = (byte) (-47);
      byteArray0[1] = byte1;
      byte byte2 = (byte) (-11);
      byteArray0[2] = byte2;
      byte byte3 = (byte) (-93);
      byteArray0[3] = byte3;
      byte byte4 = (byte)0;
      byteArray0[4] = byte4;
      byte byte5 = (byte)0;
      byteArray0[5] = byte5;
      byte byte6 = (byte) (-87);
      byteArray0[6] = byte6;
      tByteIntHashMap1._set = byteArray0;
      int int0 = (-996);
      float float0 = 0.5F;
      byte byte7 = (byte)0;
      int int1 = (-1);
      TByteIntHashMap tByteIntHashMap2 = new TByteIntHashMap(int0, float0, byte7, int1);
      byte byte8 = (byte)24;
      tByteIntHashMap2.increment(byte8);
      byte byte9 = (byte) (-27);
      tByteIntHashMap2.putIfAbsent(byte9, byte8);
      int int2 = 984;
      TByteIntHashMap tByteIntHashMap3 = new TByteIntHashMap(int2);
      byte byte10 = (byte) (-124);
      tByteIntHashMap3.increment(byte10);
      tByteIntHashMap3.values();
      TByteProcedure tByteProcedure0 = null;
      boolean boolean0 = false;
      tByteIntHashMap2.reenableAutoCompaction(boolean0);
      assertEquals(false, tByteIntHashMap2.isEmpty());
      
      tByteIntHashMap3.forEach(tByteProcedure0);
      tByteIntHashMap3.size();
      assertFalse(tByteIntHashMap3.equals(tByteIntHashMap2));
  }

  @Test
  public void test4()  throws Throwable  {
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap();
      int int0 = 0;
      boolean boolean0 = tByteIntHashMap0.containsValue(int0);
      assertEquals(false, boolean0);
      assertEquals(23, tByteIntHashMap0.capacity());
  }

  @Test
  public void test5()  throws Throwable  {
      int int0 = 54;
      Integer integer0 = new Integer(int0);
      String string0 = "Z";
      AbstractMap.SimpleEntry<Integer, String> abstractMap_SimpleEntry0 = new AbstractMap.SimpleEntry<Integer, String>(integer0, string0);
      Locale locale0 = Locale.ROOT;
      String string1 = locale0.getScript();
      boolean boolean0 = abstractMap_SimpleEntry0.equals((Object) string1);
      assertEquals(false, boolean0);
  }

  @Test
  public void test6()  throws Throwable  {
      int int0 = (-1000);
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(int0);
      int int1 = 0;
      byte[] byteArray0 = new byte[9];
      byte byte0 = (byte)64;
      TByteProcedure tByteProcedure0 = null;
      boolean boolean0 = tByteIntHashMap0.forEachKey(tByteProcedure0);
      byteArray0[0] = byte0;
      byte byte1 = (byte)20;
      byteArray0[1] = byte1;
      byte byte2 = (byte)0;
      byteArray0[2] = byte2;
      byte byte3 = (byte)40;
      byteArray0[3] = byte3;
      int int2 = 0;
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream(int2);
      String string0 = byteArrayOutputStream0.toString();
      boolean boolean1 = tByteIntHashMap0.equals((Object) string0);
      assertFalse(boolean1 == boolean0);
      
      byte byte4 = (byte)0;
      byteArray0[4] = byte4;
      byte byte5 = (byte) (-64);
      byteArray0[5] = byte5;
      byte byte6 = (byte)10;
      byteArray0[6] = byte6;
      byte byte7 = (byte)0;
      byteArray0[7] = byte7;
      byte byte8 = (byte)0;
      byteArray0[8] = byte8;
      int[] intArray0 = new int[4];
      intArray0[0] = (int) byteArray0[7];
      intArray0[1] = (int) byteArray0[7];
      intArray0[2] = (int) byte0;
      intArray0[3] = (int) byte7;
      TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap(byteArray0, intArray0);
      int int3 = tByteIntHashMap1.hashCode();
      assertEquals(4, tByteIntHashMap1.size());
      assertEquals(23, tByteIntHashMap1.capacity());
      assertEquals(188, int3);
      
      TByteIntHashMap tByteIntHashMap2 = new TByteIntHashMap(int1);
      tByteIntHashMap2.getNoEntryKey();
      assertFalse(int1 == int3);
  }

//   @Test
//   public void test7()  throws Throwable  {
//       int int0 = 0;
//       byte[] byteArray0 = new byte[3];
//       byte byte0 = (byte)0;
//       byteArray0[0] = byte0;
//       byte byte1 = (byte) (-7);
//       byteArray0[1] = byte1;
//       byte byte2 = (byte) (-5);
//       byteArray0[2] = byte2;
//       int[] intArray0 = new int[9];
//       intArray0[0] = (int) byteArray0[0];
//       intArray0[1] = int0;
//       intArray0[0] = (int) byte2;
//       int int1 = 640;
//       intArray0[1] = int1;
//       int int2 = (-815);
//       intArray0[2] = int2;
//       intArray0[3] = (int) byteArray0[2];
//       intArray0[4] = int0;
//       intArray0[5] = (int) byte1;
//       intArray0[6] = int2;
//       intArray0[7] = (int) byte2;
//       intArray0[8] = (int) byte1;
//       int int3 = 0;
//       intArray0[2] = int3;
//       intArray0[3] = (int) byte0;
//       intArray0[4] = (int) byte1;
//       intArray0[5] = (int) byteArray0[2];
//       intArray0[6] = (int) byteArray0[0];
//       intArray0[7] = (int) byte0;
//       intArray0[8] = (int) byte1;
//       TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(byteArray0, intArray0);
//       TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap((TByteIntMap) tByteIntHashMap0);
//       assertEquals(0, tByteIntHashMap1.getNoEntryKey());
//       assertEquals(0, tByteIntHashMap1.getNoEntryValue());
//       assertEquals("{-7=640, -5=0, 0=-5}", tByteIntHashMap1.toString());
//       
//       boolean boolean0 = true;
//       tByteIntHashMap0.reenableAutoCompaction(boolean0);
//       assertEquals(false, tByteIntHashMap0.isEmpty());
//       assertEquals("{-7=640, -5=0, 0=-5}", tByteIntHashMap0.toString());
//       
//       TByteIntHashMap tByteIntHashMap2 = new TByteIntHashMap(int0);
//       boolean boolean1 = tByteIntHashMap2.isEmpty();
//       assertEquals(true, boolean1);
//   }

  @Test
  public void test8()  throws Throwable  {
      int int0 = 660;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(int0);
      byte[] byteArray0 = new byte[10];
      byte byte0 = (byte)38;
      byteArray0[0] = byte0;
      byte byte1 = (byte)0;
      byteArray0[1] = byte1;
      byte byte2 = (byte)16;
      byteArray0[2] = byte2;
      byte byte3 = (byte)0;
      byteArray0[3] = byte3;
      byte byte4 = (byte) (-31);
      byteArray0[4] = byte4;
      byte byte5 = (byte)81;
      byteArray0[5] = byte5;
      byte byte6 = (byte)31;
      byteArray0[6] = byte6;
      byte byte7 = (byte) (-72);
      byteArray0[7] = byte7;
      byte byte8 = (byte)0;
      byteArray0[8] = byte8;
      byte byte9 = (byte) (-76);
      byteArray0[9] = byte9;
      byte[] byteArray1 = tByteIntHashMap0.keys(byteArray0);
      assertNotNull(byteArray1);
      
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(tByteIntHashMap0._set);
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream((InputStream) byteArrayInputStream0);
        fail("Expecting exception: StreamCorruptedException");
      
      } catch(StreamCorruptedException e) {
         //
         // invalid stream header: 00000000
         //
      }
  }

  @Test
  public void test9()  throws Throwable  {
      int int0 = (-1652);
      byte[] byteArray0 = new byte[6];
      int int1 = (-813);
      float float0 = 1246.7706F;
      byte byte0 = (byte) (-71);
      int int2 = 0;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(int1, float0, byte0, int2);
      byte byte1 = (byte) (-1);
      byteArray0[0] = byte1;
      byte byte2 = (byte) (-54);
      int int3 = 1045;
      ByteArrayOutputStream byteArrayOutputStream0 = new ByteArrayOutputStream();
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream((OutputStream) byteArrayOutputStream0);
      tByteIntHashMap0.writeExternal((ObjectOutput) objectOutputStream0);
      TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap(int3);
      tByteIntHashMap1.ensureCapacity((int) byte2);
      byteArray0[1] = byte2;
      byte byte3 = (byte)0;
      byteArray0[2] = byte3;
      byte byte4 = (byte)0;
      byteArray0[3] = byte4;
      byte byte5 = (byte) (-33);
      tByteIntHashMap0.putIfAbsent(byteArray0[2], int3);
      assertEquals(1, tByteIntHashMap0.size());
      
      byteArray0[4] = byte5;
      byte byte6 = (byte)0;
      tByteIntHashMap1.trimToSize();
      byteArray0[5] = byte6;
      int[] intArray0 = new int[2];
      intArray0[0] = (int) byte2;
      intArray0[1] = int0;
      TByteIntHashMap tByteIntHashMap2 = new TByteIntHashMap(byteArray0, intArray0);
      tByteIntHashMap2.getNoEntryKey();
      TIntProcedure tIntProcedure0 = null;
      tByteIntHashMap1.forEachValue(tIntProcedure0);
      float float1 = 0.5F;
      byte byte7 = (byte)15;
      TByteIntHashMap tByteIntHashMap3 = new TByteIntHashMap(int0, float1, byte7, int0);
      boolean boolean0 = tByteIntHashMap2.adjustValue(byte4, byte2);
      assertEquals(false, boolean0);
  }

  @Test
  public void test10()  throws Throwable  {
      TByteIntMap tByteIntMap0 = null;
      TByteIntHashMap tByteIntHashMap0 = null;
      try {
        tByteIntHashMap0 = new TByteIntHashMap(tByteIntMap0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  public void test11()  throws Throwable  {
      int int0 = 1944;
      float float0 = 41.7926F;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(int0, float0);
      boolean boolean0 = false;
      tByteIntHashMap0.reenableAutoCompaction(boolean0);
      assertEquals(47, tByteIntHashMap0.capacity());
      
      TByteIntHashMap tByteIntHashMap1 = new TByteIntHashMap();
      int int1 = tByteIntHashMap1.capacity();
      assertEquals(23, int1);
  }

  @Test
  public void test12()  throws Throwable  {
      byte[] byteArray0 = new byte[4];
      byte byte0 = (byte)0;
      byteArray0[0] = byte0;
      byte byte1 = (byte)114;
      byteArray0[1] = byte1;
      byte byte2 = (byte) (-1);
      byteArray0[2] = byte2;
      byte byte3 = (byte)0;
      byteArray0[3] = byte3;
      int[] intArray0 = new int[10];
      intArray0[0] = (int) byte1;
      intArray0[1] = (int) byteArray0[1];
      intArray0[2] = (int) byte3;
      intArray0[3] = (int) byteArray0[0];
      intArray0[4] = (int) byte0;
      intArray0[5] = (int) byteArray0[0];
      intArray0[6] = (int) byteArray0[0];
      intArray0[7] = (int) byte3;
      intArray0[8] = (int) byte2;
      intArray0[9] = (int) byte1;
      TByteIntHashMap tByteIntHashMap0 = new TByteIntHashMap(byteArray0, intArray0);
      byte[] byteArray1 = tByteIntHashMap0.keys(byteArray0);
      assertEquals("{114=114, -1=0, 0=0}", tByteIntHashMap0.toString());
      assertNotNull(byteArray1);
      assertEquals(23, tByteIntHashMap0.capacity());
      assertEquals(3, tByteIntHashMap0.size());
      assertSame(byteArray1, byteArray0);
  }
}
