/*
 * This file was automatically generated by EvoSuite
 */

package gnu.trove.map.hash;

import org.junit.Test;
import static org.junit.Assert.*;
import gnu.trove.list.linked.TByteLinkedList;
import gnu.trove.map.custom_hash.TObjectByteCustomHashMap;
import gnu.trove.map.hash.TObjectByteHashMap;
import gnu.trove.strategy.HashingStrategy;
import gnu.trove.strategy.IdentityHashingStrategy;
import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.PipedInputStream;
import java.lang.reflect.Array;
import java.util.AbstractMap;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;

public class TObjectByteHashMapEvoSuite_Random {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.utils.LoggingUtils.setLoggingForJUnit(); 
    org.evosuite.Properties.REPLACE_CALLS = true; 
    org.evosuite.agent.InstrumentingAgent.initialize(); 
  } 

  @Before 
  public void initTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.activate(); 
  } 

  @After 
  public void doneWithTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.deactivate(); 
  } 


  @Test
  public void test0()  throws Throwable  {
      int int0 = 0;
      float float0 = 1.0F;
      byte byte0 = (byte) (-89);
      TObjectByteHashMap<TObjectByteCustomHashMap<String>> tObjectByteHashMap0 = new TObjectByteHashMap<TObjectByteCustomHashMap<String>>(int0, float0, byte0);
      IdentityHashingStrategy<Object> identityHashingStrategy0 = new IdentityHashingStrategy<Object>();
      TObjectByteCustomHashMap<String> tObjectByteCustomHashMap0 = new TObjectByteCustomHashMap<String>((HashingStrategy<? super String>) identityHashingStrategy0);
      byte byte1 = (byte)0;
      byte byte2 = tObjectByteHashMap0.putIfAbsent(tObjectByteCustomHashMap0, byte1);
      assertEquals(1, tObjectByteHashMap0.size());
      assertEquals((byte) (-89), byte2);
  }

  @Test
  public void test1()  throws Throwable  {
      int int0 = (-2038);
      int int1 = (-1);
      TObjectByteHashMap<Integer> tObjectByteHashMap0 = new TObjectByteHashMap<Integer>(int1);
      tObjectByteHashMap0.iterator();
      TObjectByteHashMap<Byte> tObjectByteHashMap1 = new TObjectByteHashMap<Byte>(int0);
      assertEquals(3, tObjectByteHashMap1.capacity());
  }

  @Test
  public void test2()  throws Throwable  {
      TObjectByteHashMap<Byte> tObjectByteHashMap0 = new TObjectByteHashMap<Byte>();
      int int0 = 0;
      tObjectByteHashMap0.size();
      PipedInputStream pipedInputStream0 = null;
      try {
        pipedInputStream0 = new PipedInputStream(int0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Pipe Size <= 0
         //
      }
  }

  @Test
  public void test3()  throws Throwable  {
      int int0 = 267713;
      float float0 = 0.0F;
      TObjectByteHashMap<TObjectByteCustomHashMap<Byte>> tObjectByteHashMap0 = new TObjectByteHashMap<TObjectByteCustomHashMap<Byte>>(int0, float0);
      InputStream inputStream0 = null;
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream(inputStream0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  public void test4()  throws Throwable  {
      TObjectByteHashMap<Object> tObjectByteHashMap0 = new TObjectByteHashMap<Object>();
      byte byte0 = (byte)0;
      Byte byte1 = new Byte(byte0);
      Object object0 = null;
      AbstractMap.SimpleImmutableEntry<Byte, Object> abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<Byte, Object>(byte1, object0);
      int int0 = (-1566);
      TObjectByteHashMap<AbstractMap.SimpleImmutableEntry<Integer, String>> tObjectByteHashMap1 = new TObjectByteHashMap<AbstractMap.SimpleImmutableEntry<Integer, String>>(int0);
      abstractMap_SimpleImmutableEntry0.hashCode();
      byte[] byteArray0 = new byte[1];
      int int1 = tObjectByteHashMap0.hashCode();
      byte byte2 = (byte)35;
      Object[] objectArray0 = new Object[6];
      objectArray0[0] = (Object) byteArray0;
      objectArray0[1] = (Object) byte2;
      objectArray0[0] = (Object) abstractMap_SimpleImmutableEntry0;
      objectArray0[1] = (Object) byte1;
      objectArray0[2] = (Object) abstractMap_SimpleImmutableEntry0;
      objectArray0[3] = (Object) int1;
      objectArray0[4] = (Object) byte0;
      objectArray0[5] = (Object) byteArray0;
      objectArray0[2] = (Object) tObjectByteHashMap0;
      objectArray0[3] = (Object) byteArray0;
      objectArray0[4] = (Object) int1;
      objectArray0[5] = (Object) tObjectByteHashMap0;
      tObjectByteHashMap0.keys(objectArray0);
      byteArray0[0] = byte2;
      tObjectByteHashMap0.keySet();
      int int2 = 203;
      String string0 = "zSw";
      AbstractMap.SimpleImmutableEntry<String, Byte> abstractMap_SimpleImmutableEntry1 = new AbstractMap.SimpleImmutableEntry<String, Byte>(string0, (Byte) byte2);
      AbstractMap.SimpleImmutableEntry<AbstractMap.SimpleImmutableEntry<String, Byte>, Object> abstractMap_SimpleImmutableEntry2 = new AbstractMap.SimpleImmutableEntry<AbstractMap.SimpleImmutableEntry<String, Byte>, Object>(abstractMap_SimpleImmutableEntry1, (Object) string0);
      abstractMap_SimpleImmutableEntry1.getValue();
      abstractMap_SimpleImmutableEntry2.getValue();
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0, int2, (int) byte2);
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream((InputStream) byteArrayInputStream0);
        fail("Expecting exception: EOFException");
      
      } catch(EOFException e) {
         //
         // no message in exception (getMessage() returned null)
         //
      }
  }

  @Test
  public void test5()  throws Throwable  {
      int int0 = 231823147;
      float float0 = 1664.0013F;
      TObjectByteHashMap<Object> tObjectByteHashMap0 = new TObjectByteHashMap<Object>(int0, float0);
      Object object0 = null;
      byte byte0 = (byte) (-30);
      byte byte1 = tObjectByteHashMap0.putIfAbsent(object0, byte0);
      assertEquals("{null=-30}", tObjectByteHashMap0.toString());
      assertEquals((byte)0, byte1);
  }

  @Test
  public void test6()  throws Throwable  {
      int int0 = 0;
      float float0 = 0.0F;
      TObjectByteHashMap<Object> tObjectByteHashMap0 = new TObjectByteHashMap<Object>(int0, float0);
      Object[] objectArray0 = tObjectByteHashMap0.keys();
      assertNotNull(objectArray0);
  }

  @Test
  public void test7()  throws Throwable  {
      int int0 = 1981;
      TObjectByteHashMap<Integer> tObjectByteHashMap0 = new TObjectByteHashMap<Integer>(int0, int0);
      TByteLinkedList tByteLinkedList0 = new TByteLinkedList();
      int int1 = 0;
      // Undeclared exception!
      try {
        tByteLinkedList0.subList(int1, int0);
        fail("Expecting exception: IndexOutOfBoundsException");
      
      } catch(IndexOutOfBoundsException e) {
         //
         // end index < 0
         //
      }
  }

  @Test
  public void test8()  throws Throwable  {
      int int0 = 1109;
      float float0 = 822.27747F;
      TObjectByteHashMap<TObjectByteHashMap<Object>> tObjectByteHashMap0 = new TObjectByteHashMap<TObjectByteHashMap<Object>>(int0, float0);
      TObjectByteHashMap<Object>[] tObjectByteHashMapArray0 = (TObjectByteHashMap<Object>[]) Array.newInstance(TObjectByteHashMap.class, 3);
      TObjectByteHashMap<Object> tObjectByteHashMap1 = new TObjectByteHashMap<Object>();
      tObjectByteHashMapArray0[0] = tObjectByteHashMap1;
      int int1 = 0;
      TObjectByteHashMap<TObjectByteHashMap<Integer>> tObjectByteHashMap2 = new TObjectByteHashMap<TObjectByteHashMap<Integer>>(int1);
      PipedInputStream pipedInputStream0 = null;
      try {
        pipedInputStream0 = new PipedInputStream(int1);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Pipe Size <= 0
         //
      }
  }
}
