/*
 * This file was automatically generated by EvoSuite
 */

package gnu.trove.map.custom_hash;

import org.junit.Test;
import static org.junit.Assert.*;
import gnu.trove.map.TObjectByteMap;
import gnu.trove.map.custom_hash.TObjectByteCustomHashMap;
import gnu.trove.procedure.TByteProcedure;
import gnu.trove.strategy.HashingStrategy;
import gnu.trove.strategy.IdentityHashingStrategy;
import java.lang.reflect.Array;
import java.util.AbstractMap;
import java.util.Map;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;

public class TObjectByteCustomHashMapEvoSuite_Random {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.utils.LoggingUtils.setLoggingForJUnit(); 
    org.evosuite.Properties.REPLACE_CALLS = true; 
    org.evosuite.agent.InstrumentingAgent.initialize(); 
  } 

  @Before 
  public void initTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.activate(); 
  } 

  @After 
  public void doneWithTestCase(){ 
    org.evosuite.agent.InstrumentingAgent.deactivate(); 
  } 


//   @Test
//   public void test0()  throws Throwable  {
//       IdentityHashingStrategy<Byte> identityHashingStrategy0 = new IdentityHashingStrategy<Byte>();
//       int int0 = 0;
//       float float0 = 10.0F;
//       byte byte0 = (byte)0;
//       TObjectByteCustomHashMap<Byte> tObjectByteCustomHashMap0 = new TObjectByteCustomHashMap<Byte>((HashingStrategy<? super Byte>) identityHashingStrategy0, int0, float0, byte0);
//       boolean boolean0 = false;
//       tObjectByteCustomHashMap0.reenableAutoCompaction(boolean0);
//       assertEquals(0, tObjectByteCustomHashMap0.getNoEntryValue());
//   }

//  @Test
//  public void test1()  throws Throwable  {
//      IdentityHashingStrategy<Byte> identityHashingStrategy0 = new IdentityHashingStrategy<Byte>();
//      int int0 = (-989);
//      byte byte0 = (byte) (-30);
//      Byte byte1 = new Byte(byte0);
//      TObjectByteCustomHashMap<AbstractMap.SimpleEntry<String, String>> tObjectByteCustomHashMap0 = new TObjectByteCustomHashMap<AbstractMap.SimpleEntry<String, String>>();
//      AbstractMap.SimpleImmutableEntry<String, Integer>[] abstractMap_SimpleImmutableEntryArray0 = (AbstractMap.SimpleImmutableEntry<String, Integer>[]) Array.newInstance(AbstractMap.SimpleImmutableEntry.class, 10);
//      AbstractMap.SimpleImmutableEntry<String, Integer> abstractMap_SimpleImmutableEntry0 = null;
//      try {
//        abstractMap_SimpleImmutableEntry0 = new AbstractMap.SimpleImmutableEntry<String, Integer>((Map.Entry<? extends String, ? extends Integer>) abstractMap_SimpleImmutableEntryArray0);
//        fail("Expecting exception: IllegalArgumentException");
//      
//      } catch(IllegalArgumentException e) {
//         //
//         // argument type mismatch
//         //
//      }
//  }

  @Test
  public void test2()  throws Throwable  {
      TObjectByteCustomHashMap<AbstractMap.SimpleEntry<Integer, Integer>> tObjectByteCustomHashMap0 = new TObjectByteCustomHashMap<AbstractMap.SimpleEntry<Integer, Integer>>();
      assertEquals(23, tObjectByteCustomHashMap0.capacity());
      
      tObjectByteCustomHashMap0.trimToSize();
      TByteProcedure tByteProcedure0 = null;
      tObjectByteCustomHashMap0.forEachValue(tByteProcedure0);
      tObjectByteCustomHashMap0.values();
      assertEquals(3, tObjectByteCustomHashMap0.capacity());
  }

  @Test
  public void test3()  throws Throwable  {
      HashingStrategy<AbstractMap.SimpleImmutableEntry<Integer, Object>> hashingStrategy0 = null;
      int int0 = 0;
      byte byte0 = (byte) (-87);
      IdentityHashingStrategy<Object> identityHashingStrategy0 = new IdentityHashingStrategy<Object>();
      float float0 = 0.0F;
      TObjectByteCustomHashMap<TObjectByteCustomHashMap<String>> tObjectByteCustomHashMap0 = new TObjectByteCustomHashMap<TObjectByteCustomHashMap<String>>((HashingStrategy<? super TObjectByteCustomHashMap<String>>) identityHashingStrategy0, int0, float0);
      TObjectByteCustomHashMap<Object> tObjectByteCustomHashMap1 = null;
      try {
        tObjectByteCustomHashMap1 = new TObjectByteCustomHashMap<Object>((HashingStrategy<? super Object>) identityHashingStrategy0, (TObjectByteMap<?>) tObjectByteCustomHashMap0);
        fail("Expecting exception: OutOfMemoryError");
      
      } catch(OutOfMemoryError e) {
         //
         // Java heap space
         //
      }
  }
}
